# --------------------
# File: hawki/core/exploit_sandbox/sandbox_manager.py
# --------------------
"""
Manages ephemeral Docker sandboxes for exploit simulation.
Discovers attack scripts dynamically and runs them against deployed contracts.
"""

import json
import logging
import tempfile
import time
from pathlib import Path
from typing import List, Dict, Any, Optional
import docker
from docker.models.containers import Container

from .docker_config import DockerConfig

logger = logging.getLogger(__name__)

class SandboxManager:
    """Sets up a sandbox, deploys contracts, and runs attack scripts."""

    def __init__(self, repo_path: Path, attack_scripts_dir: Optional[Path] = None):
        self.repo_path = repo_path.resolve()
        self.attack_scripts_dir = (attack_scripts_dir or 
                                   Path(__file__).parent / "attack_scripts").resolve()
        self.docker_cfg = DockerConfig()
        self.client = docker.from_env()
        self.container: Optional[Container] = None
        self.results: List[Dict[str, Any]] = []

    def _discover_attack_scripts(self) -> List[Path]:
        """Return a list of all Python attack scripts in the attack_scripts directory."""
        if not self.attack_scripts_dir.exists():
            logger.warning(f"Attack scripts directory not found: {self.attack_scripts_dir}")
            return []
        scripts = list(self.attack_scripts_dir.glob("*.py"))
        # Exclude __init__.py
        scripts = [s for s in scripts if s.name != "__init__.py"]
        logger.info(f"Discovered {len(scripts)} attack scripts")
        return scripts

    def _start_container(self) -> Container:
        """Start a sandbox container with repo and attack scripts mounted."""
        # Mount repo as read-only (we don't want scripts to modify it)
        volumes = {
            str(self.repo_path): {"bind": "/repo", "mode": "ro"},
            str(self.attack_scripts_dir): {"bind": "/attack_scripts", "mode": "ro"},
        }
        # Also mount a temp dir for output
        self.temp_dir = tempfile.mkdtemp(prefix="hawki_sandbox_")
        volumes[str(self.temp_dir)] = {"bind": "/output", "mode": "rw"}

        container = self.client.containers.run(
            image=self.docker_cfg.IMAGE_NAME,
            command="tail -f /dev/null",  # Keep container alive
            detach=True,
            volumes=volumes,
            working_dir="/workspace",
            network_mode="bridge",
            mem_limit="2g",
            cpu_shares=512,
            remove=True,  # Auto-remove after stop
        )
        logger.info(f"Started sandbox container {container.id[:12]}")
        return container

    def _deploy_contracts(self) -> Optional[Dict[str, str]]:
        """
        Run deployment script inside container.
        Returns a dict mapping contract names to addresses, or None on failure.
        """
        # Copy deployment script into container (we'll provide a default one)
        deploy_script = Path(__file__).parent / "deploy.py"
        if not deploy_script.exists():
            # Create default deployment script
            deploy_script.parent.mkdir(parents=True, exist_ok=True)
            with open(deploy_script, "w") as f:
                f.write("""#!/usr/bin/env python3
# --------------------
# File: deploy.py (auto-generated)
# --------------------
\"\"\"Deploys all Solidity contracts in /repo using solcx and web3.\"\"\"

import json
import logging
import os
import glob
from pathlib import Path

from solcx import compile_files, install_solc
from web3 import Web3
from web3.middleware import geth_poa_middleware

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("deploy")

def main():
    # Connect to local Anvil
    w3 = Web3(Web3.HTTPProvider("http://localhost:8545"))
    w3.middleware_onion.inject(geth_poa_middleware, layer=0)
    assert w3.is_connected(), "Failed to connect to blockchain"

    # Use first account as deployer
    deployer = w3.eth.accounts[0]
    logger.info(f"Deployer: {deployer}")

    # Install solc (use latest 0.8.x)
    install_solc("0.8.24")
    from solcx import set_solc_version
    set_solc_version("0.8.24")

    # Find all .sol files
    sol_files = glob.glob("/repo/**/*.sol", recursive=True)
    if not sol_files:
        logger.error("No Solidity files found in /repo")
        return

    # Compile
    compiled = compile_files(sol_files, output_values=["abi", "bin"])
    logger.info(f"Compiled {len(compiled)} contracts")

    addresses = {}
    for contract_name, data in compiled.items():
        if not data["bin"]:
            logger.warning(f"Contract {contract_name} has no bytecode (maybe interface/abstract)")
            continue
        abi = data["abi"]
        bytecode = data["bin"]

        # Deploy
        Contract = w3.eth.contract(abi=abi, bytecode=bytecode)
        tx_hash = Contract.constructor().transact({"from": deployer})
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
        address = tx_receipt.contractAddress
        logger.info(f"Deployed {contract_name} at {address}")
        addresses[contract_name] = address

    # Save addresses to /output/addresses.json
    with open("/output/addresses.json", "w") as f:
        json.dump(addresses, f, indent=2)
    logger.info("Addresses saved")

if __name__ == "__main__":
    main()
""")
            logger.info("Created default deployment script")

        # Copy deploy.py into container
        with open(deploy_script, "rb") as f:
            data = f.read()
        self.container.put_archive("/workspace", data)  # This is tricky; better to mount it
        # Actually we mounted the attack_scripts dir, but deploy.py is separate. Let's mount it from a temp location.
        # Simpler: we'll run a command that copies the file from host? Or we can exec and pipe.
        # Alternative: include deploy.py in the image. But that's not dynamic.
        # For now, we'll write deploy.py to a temp location and mount it.
        # Let's revise: we already mounted the attack_scripts dir, we can place deploy.py there and then run it.
        # But deploy.py is not an attack script; it's a utility. We'll put it in a known location: /workspace/deploy.py via copying.

        # Use docker-py's put_archive requires tar archive. We'll use exec to write via shell.
        # Simpler: we can create a temporary file in container using `docker exec ... tee`.
        # Let's do that.

        # Write deploy.py to container using `cat`
        with open(deploy_script, "r") as f:
            deploy_content = f.read()
        # Escape for shell
        # import shlex
        cmd = f"cat > /workspace/deploy.py << 'EOF'\n{deploy_content}\nEOF"
        exit_code, output = self.container.exec_run(cmd, shell=True)
        if exit_code != 0:
            logger.error(f"Failed to write deploy.py: {output}")
            return None

        # Start anvil in background
        self.container.exec_run("anvil --host 0.0.0.0 --port 8545 &", detach=True)
        time.sleep(2)  # Give anvil time to start

        # Run deployment script
        exit_code, output = self.container.exec_run("python /workspace/deploy.py")
        if exit_code != 0:
            logger.error(f"Deployment failed: {output.decode()}")
            return None

        # Read addresses from /output/addresses.json
        import tarfile
        stream, _ = self.container.get_archive("/output/addresses.json")
        with tempfile.NamedTemporaryFile() as tmp:
            for chunk in stream:
                tmp.write(chunk)
            tmp.flush()
            with tarfile.open(tmp.name) as tar:
                member = tar.getmember("addresses.json")
                f = tar.extractfile(member)
                addresses = json.load(f)
        logger.info(f"Deployed {len(addresses)} contracts")
        return addresses

    def _run_attack_script(self, script_path: Path, addresses: Dict[str, str]) -> Dict[str, Any]:
        script_name = script_path.name
        # Copy script to container (simplified: mount already)
        # Execute script and capture stdout
        addresses_json = json.dumps(addresses)
        cmd = f"python /workspace/attack_scripts/{script_name}"
        exit_code, output = self.container.exec_run(
            cmd,
            environment={"CONTRACT_ADDRESSES": addresses_json},
        )
        output_str = output.decode()
        success = exit_code == 0

        # Try to parse JSON from output
        result = {
            "attack_name": script_name,
            "success": False,
            "before_balance": 0,
            "after_balance": 0,
            "gas_used": 0,
            "transaction_hash": "",
            "logs": output_str,
        }
        # Look for JSON at the end of output (assuming script prints JSON last)
        lines = output_str.strip().split('\n')
        for line in reversed(lines):
            try:
                data = json.loads(line)
                if isinstance(data, dict):
                    result.update(data)
                    break
            except:
                continue

        return result

    def run_all(self) -> List[Dict[str, Any]]:
        """
        Orchestrate the full sandbox simulation.
        Returns a list of results for each attack script.
        """
        try:
            self.container = self._start_container()
            addresses = self._deploy_contracts()
            if not addresses:
                logger.error("Deployment failed, aborting attack simulation")
                return []

            scripts = self._discover_attack_scripts()
            for script in scripts:
                logger.info(f"Running attack script: {script.name}")
                result = self._run_attack_script(script, addresses)
                self.results.append(result)

            return self.results
        finally:
            self.cleanup()

    def cleanup(self):
        """Stop and remove the container, clean up temp dir."""
        if self.container:
            try:
                self.container.stop(timeout=5)
                logger.info("Sandbox container stopped")
            except Exception as e:
                logger.warning(f"Error stopping container: {e}")
        if hasattr(self, 'temp_dir') and Path(self.temp_dir).exists():
            import shutil
            shutil.rmtree(self.temp_dir, ignore_errors=True)
            logger.debug("Temp directory cleaned up")

# EOF: hawki/core/exploit_sandbox/sandbox_manager.py